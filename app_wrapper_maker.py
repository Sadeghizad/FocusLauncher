import os
import sys
import shutil
from pathlib import Path

from PySide6 import QtWidgets, QtGui, QtCore

# Optional desktop shortcut (only if pywin32 installed)
try:
    import win32com.client  # type: ignore
    HAS_PYWIN32 = True
except Exception:
    HAS_PYWIN32 = False

APP_TITLE = "App Session Wrapper Maker"

DEFAULT_LOG_DIR = Path.home() / "Desktop" / "AppUsageLogs"

QSS = """
* { font-family: Segoe UI, Inter, Arial; font-size: 13px; }
QWidget { background: #0f1115; color: #e6e6e6; }
QLineEdit, QSpinBox, QComboBox, QTextEdit {
  background: #1a1f29; border: 1px solid #2a3240; border-radius: 8px; padding: 8px; color: #e6e6e6;
}
QPushButton {
  background: #2d6cdf; border: none; color: white; padding: 10px 14px; border-radius: 10px;
}
QPushButton:hover { background: #3a78ea; }
QPushButton:disabled { background: #2a3240; color: #8c8c8c; }
QGroupBox {
  border: 1px solid #2a3240; border-radius: 12px; margin-top: 16px; padding: 10px;
}
QGroupBox::title { subcontrol-origin: margin; left: 12px; padding: 0 6px; color: #9fb4ff; }
QLabel[hint="true"] { color: #98a2b3; font-size: 12px; }
"""

POPUP_VBS = r'''Set shell = CreateObject("WScript.Shell")
msg = WScript.Arguments(0)
title = WScript.Arguments(1)
' 0 = wait until user closes; 64 = info icon
shell.Popup msg, 0, title, 64
'''

APP_VBS_TEMPLATE = r'''Dim reason, fso, file, shell, logDir, logFile, batch, t
logDir = "{log_dir}"
logFile = logDir & "\{app_name}.log"
batch = ".\{app_name}.bat"

Set fso = CreateObject("Scripting.FileSystemObject")
If Not fso.FolderExists(logDir) Then fso.CreateFolder(logDir)

reason = InputBox("Why do you want to open {app_friendly}?", "{app_friendly} Launch Reason")
If reason = "" Then WScript.Quit

' Safe ASCII timestamp
t = Year(Now) & "-" & Right("0" & Month(Now),2) & "-" & Right("0" & Day(Now),2) & " " & _
    Right("0" & Hour(Now),2) & ":" & Right("0" & Minute(Now),2) & ":" & Right("0" & Second(Now),2)

Set file = fso.OpenTextFile(logFile, 8, True)
file.WriteLine "[" & t & "] [START] Reason: " & reason
file.Close

Set shell = CreateObject("WScript.Shell")
shell.Run Chr(34) & batch & Chr(34), 0
Set shell = Nothing
'''

APP_BAT_TEMPLATE = r'''@echo off
setlocal enabledelayedexpansion

:: Auto-generated by App Session Wrapper Maker

set "logDir={log_dir}"
set "logFile=%logDir%\{app_name}.log"

:: appName: what to start (full path)
:: processName: the running process name seen in Task Manager > Details
set "appName={exe_path}"
set "processName={process_name}"

set "duration={duration}"
set "warn1={warn1}"
set "warn2={warn2}"

if not exist "%logDir%" mkdir "%logDir%"

:: Start the real app
start "" "%appName%"

:: Log what we're monitoring (debug)
echo [%date% %time%] [INFO] Monitoring process: %processName% >> "%logFile%"

set /a elapsed=0
set "didWarn1=0"
set "didWarn2=0"

:loop
timeout /t 1 /nobreak >nul
set /a elapsed+=1

:: still running?
tasklist /FI "IMAGENAME eq %processName%" | find /I "%processName%" >nul
if errorlevel 1 goto user_closed

if !didWarn1!==0 if !elapsed! GEQ %warn1% (
    set "didWarn1=1"
    start "" wscript.exe "popup.vbs" "{warn1_msg}" "Warning"
)

if !didWarn2!==0 if !elapsed! GEQ %warn2% (
    set "didWarn2=1"
    start "" wscript.exe "popup.vbs" "{warn2_msg}" "Final Warning"
)

if !elapsed! GEQ %duration% goto time_up

goto loop

:user_closed
echo [%date% %time%] [END] {app_friendly} closed by user after !elapsed! seconds.>>"%logFile%"
exit

:time_up
taskkill /f /im %processName% >nul 2>&1
echo [%date% %time%] [END] {app_friendly} closed after %duration% seconds.>>"%logFile%"
exit
'''

def make_shortcut(vbs_path: Path, app_name: str, icon_path: Path):
    if not HAS_PYWIN32:
        return False, "pywin32 not installed; skipping shortcut."
    desktop = Path(os.path.join(os.environ["USERPROFILE"], "Desktop"))
    lnk = desktop / f"{app_name}.lnk"
    shell = win32com.client.Dispatch("WScript.Shell")
    shortcut = shell.CreateShortCut(str(lnk))
    shortcut.Targetpath = str(vbs_path)
    shortcut.WorkingDirectory = str(vbs_path.parent)
    shortcut.IconLocation = f"{icon_path},0"
    shortcut.save()
    return True, f"Shortcut created: {lnk}"

class Main(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(APP_TITLE)
        self.setMinimumSize(720, 520)
        self.setStyleSheet(QSS)
        self.build_ui()

    def build_ui(self):
        layout = QtWidgets.QVBoxLayout(self)
        hdr = QtWidgets.QLabel("Create a time-limited launcher for any Windows app")
        fnt = hdr.font()
        fnt.setPointSize(16)
        fnt.setBold(True)
        hdr.setFont(fnt)
        layout.addWidget(hdr)

        gb1 = QtWidgets.QGroupBox("App")
        f1 = QtWidgets.QFormLayout(gb1)

        self.exe_edit = QtWidgets.QLineEdit()
        btn_browse = QtWidgets.QPushButton("Browseâ€¦")
        btn_browse.clicked.connect(self.pick_exe)
        row1 = QtWidgets.QHBoxLayout()
        row1.addWidget(self.exe_edit)
        row1.addWidget(btn_browse)
        f1.addRow("Executable (.exe):", row1)

        self.app_name_edit = QtWidgets.QLineEdit()
        self.app_name_edit.setPlaceholderText("Readable name (e.g., Telegram, Spotify)")
        f1.addRow("App name:", self.app_name_edit)

        self.proc_edit = QtWidgets.QLineEdit()
        self.proc_edit.setPlaceholderText("Process name (e.g., Telegram.exe)")
        f1.addRow("Process name:", self.proc_edit)

        layout.addWidget(gb1)

        gb2 = QtWidgets.QGroupBox("Timing")
        f2 = QtWidgets.QFormLayout(gb2)

        self.duration = QtWidgets.QSpinBox()
        self.duration.setRange(10, 24*60*60)
        self.duration.setValue(180)

        self.warn1 = QtWidgets.QSpinBox()
        self.warn1.setRange(0, 24*60*60)
        self.warn1.setValue(120)

        self.warn2 = QtWidgets.QSpinBox()
        self.warn2.setRange(0, 24*60*60)
        self.warn2.setValue(150)

        f2.addRow("Total duration (seconds):", self.duration)
        f2.addRow("First warning (sec):", self.warn1)
        f2.addRow("Second warning (sec):", self.warn2)

        layout.addWidget(gb2)

        gb3 = QtWidgets.QGroupBox("Output & Logging")
        f3 = QtWidgets.QFormLayout(gb3)

        self.out_dir = QtWidgets.QLineEdit()
        self.out_dir.setText(str(Path.home() / "Documents" / "AppSessionWrappers"))
        btn_out = QtWidgets.QPushButton("Chooseâ€¦")
        btn_out.clicked.connect(self.pick_outdir)
        row2 = QtWidgets.QHBoxLayout()
        row2.addWidget(self.out_dir)
        row2.addWidget(btn_out)
        f3.addRow("Output folder:", row2)

        self.log_dir = QtWidgets.QLineEdit()
        self.log_dir.setText(str(DEFAULT_LOG_DIR))
        btn_log = QtWidgets.QPushButton("Chooseâ€¦")
        btn_log.clicked.connect(self.pick_logdir)
        row3 = QtWidgets.QHBoxLayout()
        row3.addWidget(self.log_dir)
        row3.addWidget(btn_log)
        f3.addRow("Log folder:", row3)

        self.shortcut_chk = QtWidgets.QCheckBox("Create Desktop shortcut to the launcher (.vbs)")
        self.shortcut_chk.setChecked(True if HAS_PYWIN32 else False)
        self.shortcut_chk.setEnabled(HAS_PYWIN32)
        hint = QtWidgets.QLabel("(Shortcut creation needs pywin32)")
        hint.setProperty("hint", "true")
        f3.addRow(self.shortcut_chk, hint)

        layout.addWidget(gb3)

        self.msg = QtWidgets.QTextEdit()
        self.msg.setReadOnly(True)
        self.msg.setPlaceholderText("Messages will appear hereâ€¦")
        layout.addWidget(self.msg)

        btn_gen = QtWidgets.QPushButton("Generate Wrapper")
        btn_gen.clicked.connect(self.generate)
        layout.addWidget(btn_gen)

    def pick_exe(self):
        fn, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select App Executable", str(Path.home()), "Executables (*.exe)")
        if not fn:
            return
        self.exe_edit.setText(fn)
        base = Path(fn).name  # e.g., Telegram.exe
        app_readable = Path(fn).stem  # "Telegram"
        if not self.app_name_edit.text():
            self.app_name_edit.setText(app_readable)
        if not self.proc_edit.text():
            # default guess: running process is same as exe name
            self.proc_edit.setText(base)

    def pick_outdir(self):
        d = QtWidgets.QFileDialog.getExistingDirectory(self, "Choose Output Folder", self.out_dir.text())
        if d:
            self.out_dir.setText(d)

    def pick_logdir(self):
        d = QtWidgets.QFileDialog.getExistingDirectory(self, "Choose Log Folder", self.log_dir.text())
        if d:
            self.log_dir.setText(d)

    def say(self, text):
        self.msg.append(text)

    def generate(self):
        exe_path = self.exe_edit.text().strip()
        app_name = self.app_name_edit.text().strip()  # readable
        process_name = self.proc_edit.text().strip()
        out_dir = Path(self.out_dir.text().strip())
        log_dir = Path(self.log_dir.text().strip())
        dur = int(self.duration.value())
        w1 = int(self.warn1.value())
        w2 = int(self.warn2.value())

        # Validation
        if not exe_path or not Path(exe_path).exists():
            self.say("âŒ Please select a valid .exe.")
            return
        if not app_name:
            self.say("âŒ Please enter an app name.")
            return
        if not process_name.lower().endswith(".exe"):
            self.say("âŒ Process name must end with .exe (e.g., chrome.exe).")
            return
        if w1 >= dur or w2 >= dur or not (0 <= w1 < w2 < dur):
            self.say("âŒ Ensure 0 â‰¤ warn1 < warn2 < duration.")
            return

        # Create output dir
        out_dir.mkdir(parents=True, exist_ok=True)
        # Ensure popup.vbs exists (shared)
        popup_file = out_dir / "popup.vbs"
        if not popup_file.exists():
            popup_file.write_text(POPUP_VBS, encoding="utf-8")

        # File base name (no spaces for convenience)
        safe_base = "".join(c for c in app_name if c.isalnum() or c in ("-", "_")).strip() or "App"
        app_bat = out_dir / f"{safe_base}.bat"
        app_vbs = out_dir / f"{safe_base}.vbs"

        # Build templates
        warn1_msg = f"{w1//60} minutes have passed. {app_name} will close soon." if w1 >= 60 else f"{w1} seconds have passed. {app_name} will close soon."
        remain = dur - w2
        warn2_msg = f"{remain} seconds left. {app_name} will be closed."

        bat_content = APP_BAT_TEMPLATE.format(
            log_dir=str(log_dir).replace("\\", "\\\\"),
            app_name=safe_base,
            exe_path=str(exe_path).replace("\\", "\\\\"),
            process_name=process_name,
            duration=dur,
            warn1=w1,
            warn2=w2,
            warn1_msg=warn1_msg.replace('"', '""'),
            warn2_msg=warn2_msg.replace('"', '""'),
            app_friendly=app_name.replace('"', '')
        )

        vbs_content = APP_VBS_TEMPLATE.format(
            log_dir=str(log_dir).replace("\\", "\\\\"),
            app_name=safe_base,
            app_friendly=app_name.replace('"', ''),
        )

        # Write files
        app_bat.write_text(bat_content, encoding="utf-8")
        app_vbs.write_text(vbs_content, encoding="utf-8")

        # Try to place popup.vbs if not present already (done above)

        # Optional Desktop shortcut
        shortcut_msg = ""
        if self.shortcut_chk.isChecked():
            ok, shortcut_msg = make_shortcut(app_vbs, safe_base,Path(exe_path))
            if not ok:
                shortcut_msg = "Skipping shortcut (pywin32 not installed)."

        self.say("âœ… Generated:")
        self.say(f"  â€¢ {app_vbs}")
        self.say(f"  â€¢ {app_bat}")
        self.say(f"  â€¢ {popup_file}")
        if shortcut_msg:
            self.say(f"  â€¢ {shortcut_msg}")

        self.say("\nðŸ‘‰ Use the **.vbs** launcher to start the app. Timers and logs will work automatically.\n"
                 "   If you close the app yourself, logging stops immediately (no further timers/popups).")

def main():
    app = QtWidgets.QApplication(sys.argv)
    w = Main()
    w.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
